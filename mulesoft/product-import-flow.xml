<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:db="http://www.mulesoft.org/schema/mule/db"
	xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
	xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns:validation="http://www.mulesoft.org/schema/mule/validation"
	xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd
http://www.mulesoft.org/schema/mule/validation http://www.mulesoft.org/schema/mule/validation/current/mule-validation.xsd">

	<!-- HTTP Listener Configuration -->
	<http:listener-config name="HTTP_Listener_config" doc:name="HTTP Listener config" doc:id="a1b2c3d4-e5f6-7890-abcd-ef1234567890" >
		<http:listener-connection host="0.0.0.0" port="8081" />
	</http:listener-config>

	<!-- Database Configuration -->
	<db:config name="Database_Config" doc:name="Database Config" doc:id="b2c3d4e5-f6g7-8901-bcde-f23456789012" >
		<db:postgresql-connection host="${db.host}" port="${db.port}" user="${db.user}" password="${db.password}" database="${db.database}" />
	</db:config>

	<!-- Flow: Product Import with Validation -->
	<flow name="product-import-flow" doc:id="c3d4e5f6-g7h8-9012-cdef-345678901234" >
		<http:listener doc:name="Listener" doc:id="d4e5f6g7-h8i9-0123-defg-456789012345" config-ref="HTTP_Listener_config" path="/products/import"/>
		
		<!-- Store original payload for later use -->
		<set-variable value="#[payload]" doc:name="Store Original Payload" doc:id="store-original" variableName="originalPayload"/>

		<!-- Validate required fields -->
		<ee:transform doc:name="Validate Input" doc:id="validate-input">
			<ee:message>
				<ee:set-payload><![CDATA[%dw 2.0
output application/java

var productData = payload

// Validation checks
var validationErrors = []

// Required fields validation
if (isEmpty(productData.product_name)) 
	validationErrors = validationErrors + "product_name is required"

if (isEmpty(productData.sku)) 
	validationErrors = validationErrors + "sku is required"

if (isEmpty(productData.brand)) 
	validationErrors = validationErrors + "brand is required"

if (isEmpty(productData.pricing.price)) 
	validationErrors = validationErrors + "pricing.price is required"

// Check if SKU already exists (this would be done in a separate database call)
// For now, we'll assume it's unique

if (sizeOf(validationErrors) > 0) {
	// Return validation errors
	{
		"valid": false,
		"errors": validationErrors
	}
} else {
	// Return validated data
	{
		"valid": true,
		"data": productData
	}
}]]></ee:set-payload>
			</ee:message>
		</ee:transform>

		<!-- Check validation result -->
		<choice doc:name="Validation Check" doc:id="validation-check">
			<when expression="#[payload.valid == false]">
				<ee:transform doc:name="Validation Error Response" doc:id="validation-error">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json

{
	"success": false,
	"error": "Validation failed",
	"validation_errors": payload.errors
}]]></ee:set-payload>
					</ee:message>
				</ee:transform>
				<set-property propertyName="http.status" value="400" doc:name="Set 400 Status" doc:id="set-400"/>
			</when>
			<otherwise>
				<!-- Transform validated data to database format -->
				<ee:transform doc:name="Transform Product Data" doc:id="transform-product">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/java

var productData = payload.data

// Transform to products table format
{
	"name": productData.product_name,
	"price": productData.pricing.price replace "$" with "" replace "," with "" as Number,
	"category": productData.collection default "General",
	"stock": 0, // Default stock
	"sku": productData.sku,
	"brand": productData.brand,
	"collection": productData.collection,
	"description": productData.description default "",
	"dimensions": productData.dimensions.dimensions default "",
	"weight": null, // Not provided in input
	"main_image_url": productData.dimensions.images.main_image_url default "",
	"is_active": true,
	"featured": false,
	"sort_order": 0
}]]></ee:set-payload>
					</ee:message>
				</ee:transform>

				<!-- Check if SKU already exists -->
				<db:select doc:name="Check SKU Exists" doc:id="check-sku" config-ref="Database_Config">
					<db:sql><![CDATA[SELECT id FROM products WHERE sku = :sku]]></db:sql>
					<db:input-parameters><![CDATA[#[{
	sku: payload.sku
}]]]></db:input-parameters>
				</db:select>

				<!-- Handle SKU conflict -->
				<choice doc:name="SKU Check" doc:id="sku-check">
					<when expression="#[sizeOf(payload) > 0]">
						<ee:transform doc:name="SKU Conflict Response" doc:id="sku-conflict">
							<ee:message>
								<ee:set-payload><![CDATA[%dw 2.0
output application/json

{
	"success": false,
	"error": "SKU already exists",
	"message": "Product with SKU '" ++ vars.originalPayload.sku ++ "' already exists in the database"
}]]></ee:set-payload>
							</ee:message>
						</ee:transform>
						<set-property propertyName="http.status" value="409" doc:name="Set 409 Status" doc:id="set-409"/>
					</when>
					<otherwise>
						<!-- Insert into products table -->
						<db:insert doc:name="Insert Product" doc:id="insert-product" config-ref="Database_Config">
							<db:sql><![CDATA[INSERT INTO products (name, price, category, stock, sku, brand, collection, description, dimensions, weight, main_image_url, is_active, featured, sort_order) 
VALUES (:name, :price, :category, :stock, :sku, :brand, :collection, :description, :dimensions, :weight, :main_image_url, :is_active, :featured, :sort_order) 
RETURNING id]]></db:sql>
						</db:insert>

						<!-- Store product ID for subsequent operations -->
						<set-variable value="#[payload[0].id]" doc:name="Set Product ID" doc:id="set-product-id" variableName="productId"/>

						<!-- Insert product images if they exist -->
						<choice doc:name="Has Images" doc:id="has-images">
							<when expression="#[vars.originalPayload.dimensions.images.main_image_url != null and vars.originalPayload.dimensions.images.main_image_url != '']">
								<ee:transform doc:name="Transform Images" doc:id="transform-images">
									<ee:message>
										<ee:set-payload><![CDATA[%dw 2.0
output application/java

var productData = vars.originalPayload
var productId = vars.productId

// Main image
var mainImage = {
	"product_id": productId,
	"image_url": productData.dimensions.images.main_image_url,
	"alt_text": productData.dimensions.images.alt_text default "",
	"is_primary": true,
	"sort_order": 0
}

// Additional images
var additionalImages = productData.dimensions.images.additional_images default [] map (image, index) -> {
	"product_id": productId,
	"image_url": image.url,
	"alt_text": image.alt_text default "",
	"is_primary": false,
	"sort_order": index + 1
}

// Combine all images
[mainImage] ++ additionalImages]]></ee:set-payload>
									</ee:message>
								</ee:transform>

								<!-- Insert product images -->
								<foreach doc:name="Insert Images" doc:id="insert-images">
									<db:insert config-ref="Database_Config">
										<db:sql><![CDATA[INSERT INTO product_images (product_id, image_url, alt_text, is_primary, sort_order) 
VALUES (:product_id, :image_url, :alt_text, :is_primary, :sort_order)]]></db:sql>
									</db:insert>
								</foreach>
							</when>
						</choice>

						<!-- Insert product features if they exist -->
						<choice doc:name="Has Features" doc:id="has-features">
							<when expression="#[sizeOf(vars.originalPayload.dimensions.features default []) > 0 or sizeOf(vars.originalPayload.dimensions.materials default []) > 0 or sizeOf(vars.originalPayload.dimensions.finish default []) > 0]">
								<ee:transform doc:name="Transform Features" doc:id="transform-features">
									<ee:message>
										<ee:set-payload><![CDATA[%dw 2.0
output application/java

var productData = vars.originalPayload
var productId = vars.productId

// Extract features from dimensions
var dimensionFeatures = productData.dimensions.features default [] map (feature) -> {
	"product_id": productId,
	"feature_name": feature[0],
	"feature_value": feature[1]
}

// Extract materials
var materialFeatures = productData.dimensions.materials default [] map (material) -> {
	"product_id": productId,
	"feature_name": "Material: " ++ material[0],
	"feature_value": material[1]
}

// Extract finish
var finishFeatures = productData.dimensions.finish default [] map (finish) -> {
	"product_id": productId,
	"feature_name": "Finish: " ++ finish[0],
	"feature_value": finish[1]
}

// Extract special features
var specialFeatures = productData.dimensions.special_features default [] map (feature, index) -> {
	"product_id": productId,
	"feature_name": "Special Feature " ++ (index + 1),
	"feature_value": feature
}

// Combine all features
dimensionFeatures ++ materialFeatures ++ finishFeatures ++ specialFeatures]]></ee:set-payload>
									</ee:message>
								</ee:transform>

								<!-- Insert product features -->
								<foreach doc:name="Insert Features" doc:id="insert-features">
									<db:insert config-ref="Database_Config">
										<db:sql><![CDATA[INSERT INTO product_features (product_id, feature_name, feature_value) 
VALUES (:product_id, :feature_name, :feature_value)]]></db:sql>
									</db:insert>
								</foreach>
							</when>
						</choice>

						<!-- Return success response -->
						<ee:transform doc:name="Success Response" doc:id="success-response">
							<ee:message>
								<ee:set-payload><![CDATA[%dw 2.0
output application/json

{
	"success": true,
	"message": "Product imported successfully",
	"product_id": vars.productId,
	"product_name": vars.originalPayload.product_name,
	"sku": vars.originalPayload.sku,
	"brand": vars.originalPayload.brand
}]]></ee:set-payload>
							</ee:message>
						</ee:transform>
					</otherwise>
				</choice>
			</otherwise>
		</choice>

		<!-- Global error handling -->
		<error-handler>
			<on-error-propagate enableNotifications="true" logException="true" doc:name="On Error Propagate" doc:id="error-handler" type="ANY">
				<ee:transform doc:name="Error Response" doc:id="error-response">
					<ee:message>
						<ee:set-payload><![CDATA[%dw 2.0
output application/json

{
	"success": false,
	"error": error.description,
	"message": "Failed to import product",
	"error_type": error.errorType.namespace ++ ":" ++ error.errorType.identifier
}]]></ee:set-payload>
					</ee:message>
				</ee:transform>
				<set-property propertyName="http.status" value="500" doc:name="Set 500 Status" doc:id="set-500"/>
			</on-error-propagate>
		</error-handler>
	</flow>

</mule>
